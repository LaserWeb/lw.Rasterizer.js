// LaserWeb namespace
var lw = lw || {};

// lw.Rasterizer scope
(function () {
    'use strict';

    // -------------------------------------------------------------------------

    // Rasterizer parser class
    lw.RasterizerParser = function() {
        this.canvasGrid   = null;
        this.currentLine  = null;
        this.lastCommands = null;
        this.beamOffset   = null;
        this.G0           = null;
    };

    // -------------------------------------------------------------------------

    // Init the parser
    lw.RasterizerParser.prototype.init = function(settings) {
        // Reset parser settings and state
        this.canvasGrid   = [];
        this.lastCommands = {};
        this.currentLine  = null;

        for (var prop in settings) {
            this[prop] = settings[prop];
        }

        // G0 command
        this.G0 = ['G', this.burnWhite ? 1 : 0];

        // Calculate beam offset
        this.beamOffset = this.beamSize * 1000 / 2000;

        // Calculate real beam range
        this.beamRange.min = this.beamRange.max / 100 * this.beamPower.min;
        this.beamRange.max = this.beamRange.max / 100 * this.beamPower.max;
    };

    // -------------------------------------------------------------------------

    // Add a new cell to the canvas grid
    lw.RasterizerParser.prototype.addCell = function(data) {
        // Canvas grid line not defined
        if (! this.canvasGrid[data.y]) {
            this.canvasGrid[data.y] = [];
        }

        // Add canvas buffer in the cell
        this.canvasGrid[data.y][data.x] = data.buffer;
    };

    // -------------------------------------------------------------------------

    // Post header GCode
    lw.RasterizerParser.prototype.postHeader = function() {
        // Output raster size in millimeters
        var width  = this.imageSize.width * this.beamSize;
        var height = this.imageSize.height * this.beamSize;

        // Base headers
        var headers = [
            '; Generated by lw.Rasterizer.js - ' + this.version,
            '; Size       : ' + width + ' x ' + height + ' mm',
            '; Resolution : ' + this.ppm + ' PPM - ' + this.ppi + ' PPI',
            '; Beam size  : ' + this.beamSize + ' mm',
            '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max,
            '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %',
            '; Feed rate  : ' + this.feedRate + ' mm/min'
        ];

        // Print activated options
        var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];

        for (var i = options.length - 1; i >= 0; i--) {
            if (! this[options[i]]) {
                options.splice(i, 1);
            }
        }

        if (options.length) {
            headers.push('; Options    : ' + options.join(', '));
        }

        // Set feed rates
        headers.push(
            '',
            'G0 F' + this.feedRate,
            'G1 F' + this.feedRate,
            ''
        );

        // Post message to main script
        postMessage({ type: 'gcode', data: {
            text   : headers.join('\n'),
            type   : 'header',
            percent: 0
        }});
    };

    // -------------------------------------------------------------------------

    // Post done parsing message
    lw.RasterizerParser.prototype.postDone = function() {
        postMessage({ type: 'done' });
    };

    // -------------------------------------------------------------------------

    // Compute and return a command, return null if not changed
    lw.RasterizerParser.prototype.command = function(name, value) {
        // If the value argument is an object
        if (typeof value === 'object') {
            // Computed commands line
            var commands = Array.prototype.slice.call(arguments);
            var command, line = [];

            // for each command
            for (var i = 0, il = commands.length; i < il; i++) {
                command = this.command.apply(this, commands[i]);
                command && line.push(command);
            }

            // Return the line if not empty
            return line.length ? line.join(' ') : null;
        }

        // Format the value
        value = value.toFixed(this.precision[name] || 0);

        // If the value was changed or if verbose mode on
        if (this.verboseG || value !== this.lastCommands[name]) {
            this.lastCommands[name] = value;
            return name + value;
        }

        // No change
        return null;
    }

    // -------------------------------------------------------------------------

    // Get a pixel power value from the canvas data grid
    lw.RasterizerParser.prototype.mapPixelPower = function(value) {
        return value * (this.beamRange.max - this.beamRange.min)
                     / 255 + this.beamRange.min;
    };

    // -------------------------------------------------------------------------

    // Get a pixel power value from the canvas data grid
    lw.RasterizerParser.prototype.getPixelPower = function(x, y, map) {
        if (x < 0 || x >= this.imageSize.width) {
            throw new Error('Out of range: x = ' + x);
        }

        if (y < 0 || y >= this.imageSize.height) {
            throw new Error('Out of range: y = ' + y);
        }

        // reverse Y value since canvas as top/left origin
        y = this.imageSize.height - y - 1;

        // Target canvas data
        var gx   = parseInt(x / this.bufferSize);
        var gy   = parseInt(y / this.bufferSize);
        var data = this.canvasGrid[gy][gx];

        // Adjuste x/y values
        gx && (x -= this.bufferSize * gx);
        gy && (y -= this.bufferSize * gy);

        // Pixel index
        var i = (y * (this.imageSize.width * 4)) + (x * 4);

        // Gray value [0 = white - 255 = black]
        var gray = 255 - ((data[i] + data[i + 1] + data[i + 2]) / 3);

        // Return pixel power
        return map ? this.mapPixelPower(gray) : gray;
    };

    // -------------------------------------------------------------------------

    lw.RasterizerParserLine = function(even) {
        this.even     = !!even;
        this.segments = [];
        this.index    = -1;
        this.length   = 0;
    };

    lw.RasterizerParserLine.prototype.addSegment = function(segment) {
        this.segments[this.even ? 'unshift' : 'push'](segment);
        this.length = this.segments.length;
    };

    lw.RasterizerParserLine.prototype.getSegment = function(index) {
        return this.segments[index] || null;
    };

    lw.RasterizerParserLine.prototype.getNextSegment = function() {
        return this.getSegment(++this.index) || null;
    };

    lw.RasterizerParserLine.prototype.rewind = function() {
        this.index = -1;
    };

    // -------------------------------------------------------------------------

    // Return point real world coordinates
    lw.RasterizerParser.prototype.getPointCoords = function(point) {
        // Real world segment coordinates
        point.X = (point.x * this.beamSize);
        point.Y = (point.y * this.beamSize);

        // Return segment object
        return point;
    };

    // Return point real world coordinates
    lw.RasterizerParser.prototype.getNextSegment = function() {
        // Get next segment
        var line    = this.currentLine;
        var segment = line.getNextSegment();

        // No more segment
        if (! segment) {
            return null;
        }

        // G command depending on pixel power
        segment.G = segment.s ? ['G', 1] : this.G0;

        // Map s value
        segment.S = this.mapPixelPower(segment.s);

        // Real world segment coordinates
        segment.p1 = this.getPointCoords(segment.p1);
        segment.p2 = this.getPointCoords(segment.p2);

        // Vertical offset
        segment.p1.Y += this.beamOffset;
        segment.p2.Y += this.beamOffset;

        // Horizontal offset
        if (segment.lastColored || segment.last) {
            segment.p2.X += line.even ? this.beamOffset : -this.beamOffset;
        }
        else if (segment.lastWhite) {
            segment.p2.X += line.even ? -this.beamOffset : this.beamOffset;
        }
        else if (segment.first) {
            segment.p1.X += line.even ? -this.beamOffset : this.beamOffset;
        }

        // Return segment
        return segment;
    };

    // -------------------------------------------------------------------------

    // Process current line and return an array of GCode text lines
    lw.RasterizerParser.prototype.processCurrentLine = function() {
        // Init loop vars...
        var command, gcode = [];

        // Get first segment
        var segment = this.getNextSegment();

        // Move to start of line (force S to 0)
        command = this.command(this.G0, ['X', segment.p1.X], ['Y', segment.p1.Y], ['S', 0]);
        command && gcode.push(command);

        // For each segments on the line
        while (segment) {
            // Burn to next pixel
            command = this.command(segment.G, ['X', segment.p2.X], ['Y', segment.p2.Y], ['S', segment.S]);
            command && gcode.push(command);

            // Get next segment
            segment = this.getNextSegment();
        }

        // Return gcode commands array
        if (gcode.length) {
            return gcode;
        }

        // Empty line
        return null;
    };

    // -------------------------------------------------------------------------

    // Parse horizontally
    lw.RasterizerParser.prototype.parseHorizontally = function() {
        // Init loop vars
        var x, y, s, p1, p2, lastSegment, even, segment, gcode;

        var w = this.imageSize.width;
        var h = this.imageSize.height;

        // For each pixels line
        for (y = 0; y < h; y++) {
            // Create new parser line
            this.currentLine = new lw.RasterizerParserLine(even);

            // reset s value
            lastSegment = { s: 0 };

            // For each pixel
            for (x = 0; x < w; x++) {
                // Segment
                p1 = { x: x, y: y };
                p2 = { x: x + 1, y: y };

                // Swap points on even line
                if (even) {
                    p2 = [p1, p1 = p2][0];
                }

                // Get pixel power
                s = this.getPixelPower(x, y);

                // Create pixel segment
                segment = { p1: p1, p2: p2, s: s };

                var type = segment.s ? 'Colored' : 'White';

                // If first/last pixel
                if (x === 0) {
                    segment[even ? 'last' : 'first'] = true;
                    segment[(segment.first ? 'first' : 'last') + type] = true;
                }
                else if (x === (w - 1)) {
                    segment[even ? 'first' : 'last'] = true;
                    segment[(segment.first ? 'first' : 'last') + type] = true;
                }
                // If first/last colored pixel
                else if (lastSegment.s == 0 && segment.s > 0) {
                    segment[even ? 'lastColored' : 'firstColored'] = true;

                    if (lastSegment.p1) {
                        if (segment.firstColored) {
                            lastSegment.lastWhite = true;
                        }
                        else if (segment.lastColored) {
                            lastSegment.firstWhite = true;
                        }
                    }
                }
                // If first/last white pixel
                else if (lastSegment.s > 0 && segment.s == 0) {
                    segment[even ? 'lastWhite' : 'firstWhite'] = true;

                    if (lastSegment.p1) {
                        if (segment.firstWhite) {
                            lastSegment.lastColored = true;
                        }
                        else if (segment.lastWhite) {
                            lastSegment.firstColored = true;
                        }
                    }
                }

                // Store last segment
                lastSegment = segment;

                // Add new line
                this.currentLine.addSegment(segment);
            }

            // Process pixels line
            gcode = this.processCurrentLine();

            // Skip empty gcode line
            if (! gcode) {
                continue;
            }

            // Toggle line state
            even = ! even;

            // Post the gcode pixels line (only if not empty)
            postMessage({ type: 'gcode', data: {
                percent: Math.round((y / h) * 100),
                text   : gcode.join('\n')
            }});
        }
    };

    // -------------------------------------------------------------------------

    // Parse diagonally
    lw.RasterizerParser.prototype.parseDiagonally = function() {

    };

    // -------------------------------------------------------------------------

    // Parse the canvas grid
    lw.RasterizerParser.prototype.parse = function() {
        // Post GCode headers
        this.postHeader();

        // Parse type ?
        if (this.diagonal) {
            this.parseDiagonally();
        }
        else {
            this.parseHorizontally();
        }

        // Post parse done
        this.postDone();
    };

})();

// =============================================================================

// Crete RasterizerParser instance
var parser = new lw.RasterizerParser();

// WebWorker: on message received
self.onmessage = function(event) {
    // Event data as message
    var message = event.data;

    // Bind to pasrer methods
    parser[message.type].call(parser, message.data);
};
