// LaserWeb namespace
var lw = lw || {};

// lw.Rasterizer scope
(function () {
    'use strict';

    // -------------------------------------------------------------------------

    // Rasterizer parser class
    lw.RasterizerParser = function() {
        this.canvasGrid   = null;
        this.currentLine  = null;
        this.lastCommands = null;
        this.beamOffset   = null;
        this.G0           = null;
    };

    // -------------------------------------------------------------------------

    // Init the parser
    lw.RasterizerParser.prototype.init = function(settings) {
        // Reset parser settings and state
        this.canvasGrid   = [];
        this.lastCommands = {};
        this.currentLine  = null;

        for (var prop in settings) {
            this[prop] = settings[prop];
        }

        // G0 command
        this.G0 = ['G', this.burnWhite ? 1 : 0];

        // Calculate beam offset
        this.beamOffset = this.beamSize * 1000 / 2000;

        // Calculate real beam range
        this.beamRange.min = this.beamRange.max / 100 * this.beamPower.min;
        this.beamRange.max = this.beamRange.max / 100 * this.beamPower.max;
    };

    // -------------------------------------------------------------------------

    // Add a new cell to the canvas grid
    lw.RasterizerParser.prototype.addCell = function(data) {
        // Canvas grid line not defined
        if (! this.canvasGrid[data.y]) {
            this.canvasGrid[data.y] = [];
        }

        // Add canvas buffer in the cell
        this.canvasGrid[data.y][data.x] = data.buffer;
    };

    // -------------------------------------------------------------------------

    // Post header GCode
    lw.RasterizerParser.prototype.postHeader = function() {
        // Output raster size in millimeters
        var width  = this.imageSize.width * this.beamSize;
        var height = this.imageSize.height * this.beamSize;

        // Base headers
        var headers = [
            '; Generated by lw.Rasterizer.js - ' + this.version,
            '; Size       : ' + width + ' x ' + height + ' mm',
            '; Resolution : ' + this.ppm + ' PPM - ' + this.ppi + ' PPI',
            '; Beam size  : ' + this.beamSize + ' mm',
            '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max,
            '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %',
            '; Feed rate  : ' + this.feedRate + ' mm/min'
        ];

        // Print activated options
        var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];

        for (var i = options.length - 1; i >= 0; i--) {
            if (! this[options[i]]) {
                options.splice(i, 1);
            }
        }

        if (options.length) {
            headers.push('; Options    : ' + options.join(', '));
        }

        // Set feed rates
        headers.push(
            '',
            'G0 F' + this.feedRate,
            'G1 F' + this.feedRate,
            ''
        );

        // Post message to main script
        postMessage({ type: 'gcode', data: {
            text   : headers.join('\n'),
            type   : 'header',
            percent: 0
        }});
    };

    // -------------------------------------------------------------------------

    // Post done parsing message
    lw.RasterizerParser.prototype.postDone = function() {
        postMessage({ type: 'done' });
    };

    // -------------------------------------------------------------------------

    // Compute and return a command, return null if not changed
    lw.RasterizerParser.prototype.command = function(name, value) {
        // If the value argument is an object
        if (typeof value === 'object') {
            // Computed commands line
            var commands = Array.prototype.slice.call(arguments);
            var command, line = [];

            // for each command
            for (var i = 0, il = commands.length; i < il; i++) {
                command = this.command.apply(this, commands[i]);
                command && line.push(command);
            }

            // Return the line if not empty
            return line.length ? line.join(' ') : null;
        }

        // Format the value
        value = value.toFixed(this.precision[name] || 0);

        // If the value was changed or if verbose mode on
        if (this.verboseG || value !== this.lastCommands[name]) {
            this.lastCommands[name] = value;
            return name + value;
        }

        // No change
        return null;
    }

    // -------------------------------------------------------------------------

    // Get a pixel power value from the canvas data grid
    lw.RasterizerParser.prototype.mapPixelPower = function(value) {
        return value * (this.beamRange.max - this.beamRange.min)
                     / 255 + this.beamRange.min;
    };

    // -------------------------------------------------------------------------

    // Get a pixel power value from the canvas data grid
    lw.RasterizerParser.prototype.getPixelPower = function(x, y, noMap) {
        if (x < 0 || x >= this.imageSize.width) {
            throw new Error('Out of range: x = ' + x);
        }

        if (y < 0 || y >= this.imageSize.height) {
            throw new Error('Out of range: y = ' + y);
        }

        // reverse Y value since canvas as top/left origin
        y = this.imageSize.height - y - 1;

        // Target canvas data
        var gx   = parseInt(x / this.bufferSize);
        var gy   = parseInt(y / this.bufferSize);
        var data = this.canvasGrid[gy][gx];

        // Adjuste x/y values
        gx && (x -= this.bufferSize * gx);
        gy && (y -= this.bufferSize * gy);

        // Pixel index
        var i = (y * (this.imageSize.width * 4)) + (x * 4);

        // Gray value [0 = white - 255 = black]
        var gray = 255 - ((data[i] + data[i + 1] + data[i + 2]) / 3);

        // Return pixel power
        return noMap ? gray : this.mapPixelPower(gray);
    };

    // -------------------------------------------------------------------------

    // Create and return an point object
    lw.RasterizerParser.prototype.createPoint = function(x, y, s) {
        // Pixel object
        var point = { x: x, X: null, y: y, Y: null, s: s, S: null };

        // Real world point coordinates
        point.X = (point.x * this.beamSize);
        point.Y = (point.y * this.beamSize);

        // Pixel power
        if (point.s === undefined) {
            point.s = this.getPixelPower(point.x, point.y, true);
        }

        // Maped point power
        point.S = this.mapPixelPower(point.s);

        // Return point object
        return point;
    };

    // -------------------------------------------------------------------------

    lw.RasterizerParserLine = function(even) {
        this.even   = !!even || false;
        this.points = [];
        this.length = 0;
        this.index  = -1;
    };

    lw.RasterizerParserLine.prototype.addPoint = function(point) {
        this.points[this.even ? 'unshift' : 'push'](point);
        this.length = this.points.length;
    };

    lw.RasterizerParserLine.prototype.getPoint = function(index) {
        return this.points[index] || null;
    };

    lw.RasterizerParserLine.prototype.getNextPoint = function() {
        return this.getPoint(++this.index) || null;
    };

    lw.RasterizerParserLine.prototype.rewind = function() {
        this.index = -1;
    };

    // -------------------------------------------------------------------------

    // ...
    lw.RasterizerParser.prototype.getNextPoint = function() {
        // Get next point from the current line
        var line  = this.currentLine;
        var point = line.getNextPoint();

        // No more point
        if (! point) {
            return null;
        }

        // If not the first call
        if (point.G) {
            return point;
        }

        // G command depending on pixel power
        point.G = point.s ? ['G', 1] : this.G0;

        // Horizontal mode
        if (! this.diagonal) {
            // Vertical offset
            point.Y += this.beamOffset;

            // If first point
            if (line.index === 0) {
                point.X += line.even ? -this.beamOffset : this.beamOffset;
            }
            else if (line.index === (line.length - 1)) {
                point.X += line.even ? this.beamOffset : -this.beamOffset;
            }
        }

        // return point
        return point;
    }

    // -------------------------------------------------------------------------

    // Process pixels line and return an array of GCode lines
    lw.RasterizerParser.prototype.processCurrentLine = function() {
        // Init loop vars...
        var point, command, gcode = [];

        // Get first point
        point = this.getNextPoint();

        // Move to start of line (force S to 0)
        command = this.command(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0]);
        command && gcode.push(command);

        // Rewind to start of line
        this.currentLine.rewind();

        // For each points on the line
        while ((point = this.getNextPoint())) {
            // Burn to next pixel
            command = this.command(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S]);
            command && gcode.push(command);
        }

        // Return gcode commands array
        if (gcode.length) {
            return gcode;
        }

        // Empty line
        return null;
    };

    // -------------------------------------------------------------------------

    // Parse horizontally
    lw.RasterizerParser.prototype.parseHorizontally = function() {
        // Init loop vars
        var x, y, s, even, point, gcode;

        var w = this.imageSize.width;
        var h = this.imageSize.height;

        // For each image line
        for (y = 0; y < h; y++) {
            // Create new line
            this.currentLine = new lw.RasterizerParserLine(even);

            // For each pixel on the line
            for (x = 0; x < w; x++) {
                // Pixel power
                s = this.getPixelPower((! even && x) ? x - 1 : x, y, true);

                // Create pixel point
                point = this.createPoint(x, y, s);

                // Add new point
                this.currentLine.addPoint(point);
            }

            // Add trailing pixel point
            this.currentLine.addPoint(this.createPoint(x, y, point.s));

            // Process pixels line
            gcode = this.processCurrentLine();

            // Skip empty gcode line
            if (! gcode) {
                continue;
            }

            // Toggle line state
            even = ! even;

            // Post the gcode pixels line (only if not empty)
            postMessage({ type: 'gcode', data: {
                percent: Math.round((y / h) * 100),
                text   : gcode.join('\n')
            }});
        }
    };

    // -------------------------------------------------------------------------

    // Parse diagonally
    lw.RasterizerParser.prototype.parseDiagonally = function() {

    };

    // -------------------------------------------------------------------------

    // Parse the canvas grid
    lw.RasterizerParser.prototype.parse = function() {
        // Post GCode headers
        this.postHeader();

        // Parse type ?
        if (this.diagonal) {
            this.parseDiagonally();
        }
        else {
            this.parseHorizontally();
        }

        // Post parse done
        this.postDone();
    };

})();

// =============================================================================

// Crete RasterizerParser instance
var parser = new lw.RasterizerParser();

// WebWorker: on message received
self.onmessage = function(event) {
    // Event data as message
    var message = event.data;

    // Bind to pasrer methods
    parser[message.type].call(parser, message.data);
};
